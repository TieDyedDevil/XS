.TH XS 1 "2020 - v1.3"
.SH NAME
xs \- extensible shell
.SH SYNOPSIS
.BR xs " [" -silevxnpod ]
.RB [ -c " \fIFRAGMENT\fP | "\fISCRIPT " [" \fIARGUMENTS ]]
.SH DESCRIPTION
.B Xs
is a command interpreter for Linux.
.B Xs
allows programming in a functional style and has a simple, consistent syntax.
.PP
.B Xs
provides hooks to customize many of its internal operations, including
primitives for exception handling and lexical and dynamic control flow.
.PP
A significant portion of
.B xs
is implemented in
.BR xs .
.PP
.B Xs
is a descendant of
.BR rc "(1) and " es (1);
the three implementations are not interoperable.
.SH OPTIONS
.TS
tab(@);
lb lx .
-s@T{
Read commands from standard input; pass the first argument to
.B xs
rather than taking the argument as the name of a file to source.
T}
-i@T{
Force
.B xs
to be an interactive shell even if commands do not come from standard input
via a terminal.
T}
-l@T{
Cause
.B xs
to be a login shell, as if it had been invoked as
.BR -xs .
T}
-e@T{
Exit if any command (apart from those appearing as tests in conditional forms
or as arguments to logical operators) returns a false status.
T}
-v@T{
Echo input to standard error.
T}
-x@T{
Print commands to standard error.
T}
-n@T{
Disable command execution.
T}
-p@T{
Don't initialize functions from the environment.
T}
-o@T{
If any of file descriptors 0, 1 or 2 are inherited closed, leave them closed
rather than open on /dev/null.
T}
-d@T{
Don't trap SIGQUIT or SIGTERM.
T}
-c \fIFRAGMENT@T{
Execute the
.IR FRAGMENT .
(See
.BR "Program fragments" ,
below.)
T}
.TE
.SH LANGUAGE
Lexically, an
.B xs
program consists of words and punctuation.
(See
.BR FOOTNOTE .)
.SS Words
In its simplest form, a word is a
sequence of non-special characters.
The special characters are:
.PP
.RS
.B "# $ & \(aq ( ) ; < > \e ^ \` { | }"
.I "space tab newline"
.RE
.PP
The empty word is denoted by
.BR \(aq\(aq .
.PP
Words are indivisible and immutable.
.SS Escapes
A special character may escaped by preceeding it with a backslash
.RB ( \e );
this defeats the character's special meaning, allowing the character
to be (part of) a word.
.PP
Other escapes denote control characters:
.PP
.RS
.TS
tab(@);
lb l .
\ea@alert (bell)
\eb@backspace
\ee@escape
\ef@form feed
\en@newline
\er@return
\et@tab
.TE
.RE
.PP
A character octet may be denoted by its hexadecimal or octal code point:
.PP
.RS
.TS
tab(@);
l lx .
\fB\ex\fInn@T{
Character octet
.IR nn ,
for
.I n
in {0..0, a..f, A..F}
T}
\fB\e\fImnn@T{
Character octet
.IR mnn ,
for
.I m
in {0..3} and
.I n
in {0..7}
T}
.TE
.RE
.PP
A UTF-8 octet sequence may be denoted using the escape sequence:
.RS
.TS
tab(@);
l lx .
\fB\eu\(aq\fIn...\fB\(aq@T{
UTF-8 character having codepoint
.IR n... ,
for one to six
.I n
in {0..9, a..f, A..F}
T}
.TE
.RE
.PP
.B Xs
does not allow scripts to contain a NUL character; thus the
following are all invalid:
.PP
.RS
.BR \e000 ", " \ex00 " and " \eu'0' .
.RE
.PP
A backslash must not be followed by a sequence of characters other than as
described above.
.SS Quoted words
A sequence of characters enclosed by apostrophes
.RB ( \(aq )
is a word; the bounding
.B \(aq
are not part of the word.
We refer to this form as a
.IR "quoted word" .
.PP
An apostrophe is written within a quoted word by doubling it, e.g.,
.PP
.RS
.BR "\(aqSam\(aq\(aqs word\(aq" " ."
.RE
.PP
All other special characters lose their meaning within a quoted word.
.SS Commands
A command is a sequence of words separated by whitespace.
The first word
is always the name of an executable program on
.BR $path ,
an
.B xs
function, or a lambda (defined below).
Subsequent words are arguments; these
are subject to evaluation, expansion and substitution.
Because the arguments
are passed as a list, any argument that yields
.B ()
will "disappear" (see
.BR Lists ).
.SS Command separator
A command must occupy one logical line.
Commands are separated by
newlines or semicolons
.RB ( ; ).
.SS Program fragments
A program fragment (henceforth fragment) is a sequence of zero or more
commands enclosed in braces:
.PP
.RS
.BI { command* } " \fR."
.RE
.PP
A fragment may span multiple physical lines.
.PP
The value of a fragment is the result code returned by the last
command executed.
An empty fragment
.RB ( {} )
has a result of zero.
A fragment containing a pipeline (see
.BR Pipes )
returns a list of results: one for each function or executable in the pipeline;
the list is true in the aggregate only if each element is true (see
.BR "Truth values" ).
.PP
A fragment appearing as a parameter of a function or executable is
treated as a single word.
Fragments are indivisible and immutable.
.PP
The braces may be elided if the command is a single word having no arguments.
.SS Comments
The hash mark
.RB ( # )
introduces a comment which ends at newline.
.SS Line continuation
Program text may be split across physical lines by ending each logical line
with a backslash
.RB ( \e ).
The backslash and the immediately following newline are read as a space.
.SS Lists
A list is a space-separated sequence of words.
The empty list is denoted by
.BR () .
All lists are flat in
.BR xs ;
balanced parentheses may be written for grouping, but they do not create
a tree.
Thus
.PP
.RS
.B this is a list of seven words
.RE
.PP
and
.PP
.RS
.B this (is a list) ((of) () (seven words)) ()
.RE
.PP
are identical.
.PP
A list enclosed in parentheses may span multiple lines without need of
line continuation characters.
.SS Concatenation
Lists may be joined using the concatenation operator, caret
.BR ( ^ ).
.PP
A list of length one is a word.
Concatenating two words creates a new word.
.PP
When either list has length greater than one, the result of concatenation is
the cross product of the lists.
.PP
When either list is empty, the result of concatenation is the empty list.
.SS Variable names
Letters, digits, all UTF-8 characters encoded as at least two octets (i.e.,
code points greater than \eu\(aq7f\(aq) and the characters percent
.RB ( % ),
star
.RB ( * ),
hyphen
.RB ( - )
and underscore
.RB ( _ )
may be used in variable names.
These characters may appear in any order or combination.
.PP
The
.B xs
special characters (see
.BR Words )
may also appear in a variable name if quoted or escaped.
Likewise, character escapes (see
.BR Escapes )
may be part of a variable name.
.PP
Variable names having the prefix
.B fn-
or
.B var-
have special meaning; see
.BR Functions " and " Settors ,
respectively.
.SS Assignment
A variable is assigned a list value using the notation
.PP
.RS
.IB var " = " list " \fR."
.RE
.PP
The spaces around
.B =
are mandatory.
.PP
A variable becomes undefined by assigning an empty list as its value.
While
.PP
.RS
.IB var " = ()"
.RE
.PP
is valid, the preferred form is
.PP
.RS
.IB var " =" "    \fR."
.RE
.PP
The value of an assignment is its assigned value.
.SS Variables
All variables are exported to the environment unless declared within a
.BR local ", " let " or " for " form (described below)."
.PP
A variable's value is retrieved by writing
.B $
before its name, like
.BI $ var
.RI .
Indirection (multiple
.BR $\fP)
is allowed.
.PP
An undefined variable yields the empty list when referenced.
.PP
A variable name may be constructed at runtime.
Parentheses must enclose expressions used to construct a name.
.SS Subscripted reference
Specific list elements may be selected via subscripting.
This takes the form
.PP
.RS
.BI $ var ( subscripts ) " \fR."
.RE
.PP
List elements are indexed starting at one.
A subscript less than 1 is an error.
A subscript greater than the number of list elements yields the empty list.
.PP
.RS
.TP
.B a = w x y z; echo $a(2 3 4 4 3)
prints
.BR "x y z z y" " ."
.RE
.PP
Subscripts may be specified as ranges by separating the range endpoints with
.BR ...\& " ."
The range operator must be separated from its arguments by spaces.
.PP
Either end of the range may be left unspecified.
.PP
.RS
.TP
.BI $ var "(... 7)"
yields elements 1 through 7 of the list.
.TP
.BI $ var "(3 ...)"
yields elements 3 through the end of the list.
.RE
.PP
Reversing the endpoints of a range returns the values in reversed order:
.PP
.RS
.TP
.B a = s d r a w k c a b; $a(5 ... 2)
yeilds the list
.BR "w a r d" " ."
.RE
.PP
If
.I subscripts
is an empty list, the result is empty.
.SS Multiple assignment
A list of variables may be specified on the left side of an assignment.
Parentheses are mandatory around the list of variables.
.PP
Corresponding list elements on the right side are assigned to variables on
the left.
If the right side has more elements than there are variables on
the left, the rightmost variable is assigned the list value of the remaining
elements.
If there are more variables than list elements, the excess variables
are assigned the empty list.
.PP
Variable names may not be computed or subscripted on the left side of a
multiple assignment.
.SS List length
The length of a list assigned to a variable is given by
.PP
.RS
.BI $# var " \fR."
.RE
.PP
.SS Flattening
A list may be flattened to a single word using the
.B $^
operator.
This yields a word composed of the words of the given list,
with a single space between each pair of words.
As with the subscript
operator, this applies only to a variable (not literal) list.
.SS Free carets
Concatenation may be written implicitly (rather than using the
.B ^
operator) in certain situations.
If a word is followed by another word,
.BR $ " or " \`
without intervening whitespace, then
.B xs
inserts a caret between them.
.SS Wildcard patterns
A pattern is a word which may contain wildcards.
.TP
.B *
Matches zero or more characters.
.TP
.B ?
Matches exactly one character.
.TP
.BI [ class ]
Matches any of the characters specified by the class, following the same
rules as those for
.BR ed (1),
except that class negation is denoted by
.B ~
since
.B ^
has another interpretation in
.BR xs .
.SS Pathname expansion
Where a word may be treated as a pathname,
.B xs
expands wildcards.
.PP
The pathname separator,
.BR / ,
is never matched by
.BR * .
The
.B ?\&
wildcard never matches a dot at the beginning of a pathname component.
.PP
A tilde
.RB ( ~ )
alone or followed by a slash
.RB ( / )
is replaced by the value of
.BR $home .
A tilde followed by a username is replaced with the home directory path
of that user.
(See
.BR getpwent (3).)
.PP
A quoted wildcard loses its meaning as a wildcard.
.SS Pattern matching
The pattern matching operator
.RB ( ~ )
returns true when a subject matches any of the given patterns:
.PP
.RS
.BI ~ " subject pattern ..." " \fR."
.RE
.PP
A subject may be a list.
If composed of individual words or expressions,
the subject list must be enclosed by parentheses.
.PP
Pattern wildcards are never expanded with pathnames from the filesystem.
.SS Pattern extraction
The pattern extraction operator
.RB ( ~~ )
returns the parts of each subject that match a wildcard in the patterns:
.PP
.RS
.BI ~~ " subject pattern ..." " \fR."
.RE
.PP
Subjects and patterns are the same as for the pattern matching operator.
.SS Arithmetic substitution
An infix arithmetic expression may be evaluated to produce a single word
representing its value:
.PP
.RS
.BI \`( expression ) " \fR."
.RE
.PP
The expression consists of numeric values and the infix operators
.BR + ", " - ", " * ", " / ", " % " (modulus), and " ** " (exponentiation);"
these obey the usual precedence and associativity rules and may
be otherwise grouped using parentheses.
.PP
A value is either a numeric constant or a variable reference yielding
a numeric value.
Numbers may be integer or floating-point; the latter are stored with limited
precision (usually six significant digits).
.PP
Integer overflow does not signal an exception.
.PP
If an expression involves any floating-point value, the result will be
floating-point.
.PP
Division of integers produces an integer result via truncation.
Modulus behaves as
.BR fmod (3)
if either argument is floating-point.
.PP
An undefined variable (a variable reference yielding value
.BR () )
is treated as zero within an arithmetic expression.
.PP
Variables having subscripted or constructed names may not be used in an
arithmetic expression.
Variable names in an expression may not be spelled using the characters
which denote the arithmetic operators.
.SS Pipes
The standard output of one fragment may be piped to the standard input of
another:
.PP
.RS
.IB fragment1 " | " fragment2 " \fR."
.RE
.PP
Other file descriptors may be connected:
.PP
.RS
.IB fragment1 " |[\fIfd1\fB=\fIfd2\fB] " fragment2 " \fR."
.RE
.PP
The form
.PP
.RS
.IB fragment1 " |[\fIfd1\fB] " fragment2
.RE
.PP
is identical to
.PP
.RS
.IB fragment2 " |[\fIfd1\fB=0] " fragment2 " \fR."
.RE
.PP
.SS Command substitution
The backquote form creates a list from the standard output of a fragment:
.PP
.RS
.BI \` fragment " \fR."
.RE
.PP
Words are parsed from the standard output using the separators defined by
.BR $ifs .
.PP
This variant backquote form binds
.B $ifs
to the given list of separators:
.PP
.RS
.BI \`\` " separators fragment" " \fR."
.RE
.SS Functions
.B Xs
has two forms by which a function is defined:
.PP
.RS
.BI fn " name fragment"
.RE
.PP
and
.PP
.RS
.BI fn- name " = " fragment " \fR."
.RE
.PP
The former is normally used for top-level and nested definitions; the latter
must be used when binding a function for local use.
Because the latter is an assignment, the spaces around
.B =
are mandatory.
.SS Lambdas
A lambda is an unnamed function.
In
.BR xs ,
a lambda is written as a fragment in which the first element may be
a lambda list (see below).
A lambda without a lambda list is a lambda with no arguments.
.SS Lambda list
A lambda list binds names to function arguments.
Its form is:
.PP
.RS
.BI | "name ..." | " \fR."
.RE
.PP
Arguments are bound to
.IR name s
left-to-right.
Excess arguments bind in a list to the last name.
Excess names are bound to
.BR () .
.PP
A lambda list may only appear as the first element of a fragment.
.SS Truth values
The values
.BR 0 ", " \(aq\(aq " and " ()
are all treated as true; everything else (including
.BR 0.0 )
is false.
A list of true values is true; a list containing an untrue value
is false.
.PP
The keywords
.BR true " and " false
are equivalent to
.BR "result 0" " and " "result 1" ,
respectively.
.SS Return values
The value of evaluating a fragment is the return value of the last function
or executable evaluated before leaving the fragment.
.PP
A specific result may be returned by:
.PP
.RS
.BI result " list" " \fR."
.RE
.SS Logical operators
The following operators apply to truth values:
.PP
.RS
.TP
.IB value1 " && " value2
True if both
.IR value1 " and " value2
are true.
.TP
.IB value1 " || " value2
True if
.I value1
is true or if
.I value1
is false and
.I value2
is true.
.TP
.BI ! " value"
True if
.I value
is false.
.RE
.PP
The
.BR && " and " ||
operators evaluate their arguments from left to right, stopping when the
value of the expression is determined.
.SS Relational operators
Numbers and strings may be compared using the relational operators:
.PP
.RS
.TP
.IB value1 " :lt " value2
True if
.I value1
is less than
.IR value2 .
.TP
.IB value1 " :le " value2
True if
.I value1
is less than or equal to
.IR value2 .
.TP
.IB value1 " :gt " value2
True if
.I value1
is greater than
.IR value2 .
.TP
.IB value1 " :ge " value2
True if
.I value1
is greater than or equal to
.IR value2 .
.TP
.IB value1 " :eq " value2
True if
.I value1
is equal to
.IR value2 .
.TP
.IB value1 " :ne " value2
True if
.I value1
is not equal to
.IR value2 .
.RE
.PP
If either argument is non-numeric, the arguments are compared according to
the current locale's collation order.
.SS Input and output
Input may be redirected from a file to standard input:
.PP
.RS
.BI < "filename fragment"
.RE
.PP
or
.PP
.RS
.IB fragment " <" filename " \fR."
.RE
.PP
It is an error if the file does not exist or is not readable.
.PP
Output may be redirected from standard output to a file:
.PP
.RS
.IB fragment " >" filename
.RE
.PP
or
.PP
.RS
.BI > "filename fragment" " \fR."
.RE
.PP
The file is created if it does not exist.
If the file already exists, its contents are replaced.
It is an error for the file to not be writable.
.PP
Other file descriptors may be specified:
.PP
.RS
.IB "fragment " >[ ofd ] filename
.RE
.PP
and
.PP
.RS
.IB "fragment " <[ ifd ] filename " \fR."
.RE
.PP
A file descriptor may be duplicated using the form:
.PP
.RS
.BI >[ fd1 = fd2 ] " \fR."
.RE
.PP
This causes output to
.I fd1
to be written instead to
.IR fd2 .
Thus,
.PP
.RS
.IB fragment " >" filename " >[2=1]" filename
.RE
.PP
causes both standard output and standard error to be written to the same file.
.PP
Other redirection operators have their own semantics:
.PP
.RS
.TP
.BI >> filename
Append to an existing file; the file is created if nonexistent.
.TP
.BI <> filename
Open a file for reading and writing (on standard input unless otherwise
specified).
.TP
.BI <>> filename
Open a file for reading and appending (on standard input unless otherwise
specified).
.TP
.BI >< filename
Truncate a file and open it for reading and writing (on standard output
unless otherwise specified).
.TP
.BI >>< filename
Open a file for reading and appending (on standard output unless otherwise
specified).
.RE
.PP
Files opened for reading must be readable.
Files opened for writing or appending must be writable.
.PP
An open file descriptor is closed using this form:
.PP
.RS
.BI >[ fd =] " \fR."
.RE
.PP
File descriptors must be integer constants.
.SS Literal input
Multiple lines of input may be read from a script using a "here document":
.PP
.RS
.IB fragment " <<" eof-marker
.RE
.PP
or
.PP
.RS
.IB fragment " <<\(aq" eof-marker \(aq " \fR."
.RE
.PP
The
.I eof-marker
is a word which must appear on a line by itself immediately following
the final newline of textual data taken as input.
.PP
The first form (with the unquoted
.IR eof-marker )
replaces variables within the textual data.
(Only simple variables; indirection, subscripts and constructed names
are not allowed.)
A
.B $
can be emitted literally by writing
.BR $$ .
To emit the value of a variable followed immediately by a literal word, write:
.BI $ var ^ "word \fR."
The caret
.RB ( ^ )
is taken literally elsewhere in a here document.
.PP
The second form (with the quoted
.IR eof-marker )
copies the textual data without substitution of any kind.
.PP
Text may also provide the content of a readable file via a "here string":
.PP
.RS
.BI <<<\(aq text \(aq " \fR."
.RE
.PP
The
.I text
may span lines.
No substitution is performed within a here string.
.PP
A here string may also be created using a variable for the content, like
.BI <<<$ var
.RI .
.SS Process substitution
.PP
Process substitution allows for the output of a command to be read from a
file descriptor or for data written to a file descriptor to be read by a
command, using the forms:
.PP
.RS
.BI <{ command+ }
.RE
.PP
and
.PP
.RS
.BI >{ command+ } " \fR."
.RE
.PP
The files created by process substitution are implemented using pipes,
which are not seekable.
.PP
Multiple
.IR command s
may appear within the braces.
.PP
Note that the braces are an essential part of this syntax; these are not
.BI > fragment
and
.BI < "fragment \fR."
.SS Local variables
Local variables exist only during execution of their binding form:
.PP
.RS
.BI "local (" "binding ..." ) " fragment \fR,"
.RE
.PP
where
.I binding
is either
.IB name " = " value
or just
.I name
(and value is taken as
.BR () ).
Multiple bindings are separated by
.BR ; .
.PP
While bound by
.BR local ,
variables are accessible within the environment.
.SS Lexical variables
Lexical variables are bound by the form:
.PP
.RS
.BI "let (" "binding ..." ) " fragment \fR,"
.RE
.PP
where
.I binding
is either
.IB name " = " value
or just
.I name
(and
.I value
is taken as
.BR () ).
Multiple bindings are separated by
.BR ; .
.PP
A lexical variable is accessible only within
.IR fragment .
Furthermore, a lexical variable persists across executions
of a function which is defined within the
.B let
form.
A lexical binding is stored as a closure in the environment.
The binding is not accessible as an environment variable.
.SS Conditionals
.B Xs
has two main conditional forms:
.PP
.RS
.BI if " condition fragment " else " fragment \fR,"
.RE
.PP
where
.I condition
is a boolean expression and the
.B else
branch is optional, and
.PP
.RS
.BI switch " var cases \fR,"
.RE
.PP
where
.I cases
is a list of
.IR "word fragment" ,
each representing the code to be executed for a specific value of
.IR var ,
followed by a
.I fragment
to be executed when none of the
.IR word s
match
.IR var .
.SS Loops
.B Xs
has these looping forms:
.PP
.RS
.BI while " condition fragment"
.RE
.RS
.BI until " condition fragment"
.RE
.RS
.BI for " vars-and-values fragment"
.RE
.RS
.BI forever " fragment"
.RE
.PP
The
.B while
form executes
.I fragment
while
.I condition
is true.
.PP
The
.B until
form executes
.I fragment
until
.I condition
is false.
.PP
The
.B for
form executes
.I fragment
with variables bound to consecutive values in
.IR vars-and-values ,
which is a sequence of one or more
.I var list
forms separated by
.BR ; .
This continues until the longest list is exhausted; shorter lists are
implicitly padded with
.B ()
to match the length of the longest list.
.PP
The
.BI forever " fragment"
form loops forever, like
.BR "while true \fIfragment" .
.SS Settors
A settor function is a variable like
.BI set- var \fR.
.PP
When
.I var
is assigned,
.BI set- var
is called as a function, passing the value to be assigned.
.B $0
is bound to the name of the variable being assigned.
The result of the settor function is used as the assignment's value.
.PP
A settor is never invoked on a lexical variable.
.SS Exceptions
Exceptions in
.B xs
are used for non-lexical control transfer.
An exception is passed up the call chain to the most recently
established catcher.
The catcher may handle the exception, retry the code which caused
the exception or throw the exception to the next catcher.
.PP
An exception is a list.
The first word denotes the exception type, one of:
.PP
.RS
.TP
.B eof
Raised by the
.B xs
parser at end of input.
.TP
.B error
The following words are the source (typically a descriptive name
such as the name of the function which signalled the error) and a message.
.B xs
provides a last-resort catcher to print the message.
.TP
.B exit
The next word is an optional numeric return code (default: 0).
This exception, when caught by
.BR xs ,
exits the shell with the given return code.
.TP
.B retry
When raised by a catcher, this causes the body of the
.B catch
form to run again.
Note that the catcher must have done something to clear
the cause of the exception; otherwise
.B retry
will cause an infinite loop.
.RE
.PP
The
.B catch
form executes its body in the context of a catcher:
.PP
.RS
.BI catch " catcher body" " \fR."
.RE
.PP
The
.IR catcher " and " body
are fragments.
.SS Signals
.B Xs
processes signals internally as needed for interactive operation.
For example,
.I SIGINT
is used to kill any foreground process and, during input, to present
a fresh prompt.
.PP
.B Xs
can expose signals for handling by a script.
Signal handlers are established by the
.I signals-case
command.
.PP
.RS
.BI signals-case " body handlers-alist" " \fR,"
.RE
.PP
where
.I body
is a fragment
and
.I handlers-alist
is a list of
.IR "signal-name fragment" .
The
.I signal-name
is spelled as in
.BR signal.h (0p),
but using lowercase letters, e.g.
.IR sigint " and " sigterm .
.PP
The
.B signals
variable (see
.BR "BUILTIN VARIABLES" ,
below) indicates which signals are accepted by
.B xs
and how they are processed.
Setting
.B signals
to a new list of handler specifications establishes signal handlers
per the list.
A signal must be listed on
.B signals
(and not disabled) in order to be handled by
.BR signals-case .
.PP
A signal not handled by a
.B signals-case
is propagated to the next
.B signals-case
handler (if any) up the call chain; a last-resort handler reports
an unhandled signal.
.PP
In this example, note that the signal is not intercepted by the
exception handler established by
.BR catch .
The code prints "sigttou".
.PP
.RS
.EX
signals = $signals sigttou
signals-case {
    catch {|e| echo catch $e} {kill -sigttou $pid}
} (sigttou {echo sigttou})
.EE
.PP
Signals are never processed within a
.BI "fork {" ... }
command.
.SS Upward funargs
An "upward funarg" is a function returned from another function.
Because a returned function may be executed in a different lexical
context, all free variables referenced by the function must be
captured in a let binding.
In other words, an upward funarg must be let-bound.
.PP
A fragment or lambda may be returned instead of a closure
.IR "only in the case where the code references no free variables" .
This practice is discouraged as it will cause your code to fail
should a free variable be added later.
.SH BUILTIN VARIABLES
These dynamic variables form a part of the programming interface to
.BR xs .
.TP
.B *
The arguments passed to
.BR xs .
Individual arguments may be referenced via subscripts or as
.BR $1 ", " $2 ", " $3 ", etc."
.TP
.B 0
At the top level, this variable
.RB "(i.e., " $0 )
is the value of
.BR xs 's
argv[0] or the name of a sourced file.
Within an executing function, the name of the function.
.TP
.B apid
The ID of the most recently started background process.
.TP
.B history
The pathname of the file to which
.B xs
appends commands read by the toplevel loop.
This may be left undefined.
.TP
.B home
The path to the current user's home directory.
.BR $home " and " $HOME
are aliased to each other.
.TP
.B ifs
The input field separator, used by backquote
.RB ( \` )
to split command output into words.
The initial value is the list
.RS
.IR "space tab newline" " ."
.RE
.TP
.B max-eval-depth
Sets an upper bound on the size of the interpreter's evaluation stack.
.TP
.B noexport
A list of dynamic variable names which
.B xs
will not export to the environment.
.TP
.B path
A list of directories to be searched for executable programs.
The current directory is denoted by the empty word
.RB ( \(aq\(aq ).
.BR $path " and " $PATH
are aliased to each other, with appropriate syntactic adjustments.
.TP
.B pid
The process ID of the running
.BR xs .
.TP
.B prompt
.B $prompt(1)
is printed before reading a command.
.B $prompt(2)
is printed before reading a continuation line.
The default,
.BR "\(aq;\(aq \(aq\(aq" ,
facilitates copy-paste from a terminal session into a script file.
.B $prompt
may contain ANSI terminal control characters and sequences.
.TP
.B signals
A list of signals trapped by
.BR xs .
For each signal name on
.BR $signals ,
.B xs
raises a correspondingly-named exception upon trapping the signal.
A signal's disposition is determined by an optional prefix to its name:
.RS
.TP
.B -
Ignore the signal, here and in child processes.
.TP
.B /
Ignore the signal here, but take its default behavior in child processes.
.TP
.BI . " (for sigint and sigwinch)"
Perform normal processing (i.e., print an extra newline upon receipt of
sigint; note the new window size upon receipt of sigwinch).
.TP
.I none
Default behavior.
.PP
The initial value of
.B $signals
is
.PP
.RS
.RI ".sigint /sigquit /sigterm -sigxcpu .sigwinch -sigpwr"
.RE
.PP
plus any signals ignored (/) when
.B xs
started.
.B xs
recognizes that
.BR sigxcpu " and " sigpwr
are used by its garbage collector and intentionally ignores them to avoid disrupting
the collector's operation.
.PP
When
.B $signals
is written, its value is used by the
.I set-signals
settor to configure the shell's signal handlers.
.RE
.PP
.B Xs
maintains
.B $SHLVL
for interoperability with other shells.
.SH BUILTIN COMMANDS
These commands are built into
.BR xs ,
and execute within the
.B xs
process.
.TP
.BR . " [-einvx] " \fIfile " [" \fIargs... ]
Sources
.IR file .
The options are a subset of those recognized by
.BR xs;
see
.BR Options .
.TP
.BR access " [" "-n " \fIname "] [-1e] [-rwx] [-fdcblsp] " \fIpath...
Tests
.IR path s
for accessibility.
Without the
.BR -1 ", " -e " and " -n
options,
.B access
returns true for
.IR path s
which are accessible as specified.
A printable error message (which evaluates as false; see
.BR "Truth values" )
is returned for
.IR path s
which are not accessible.
The default test (no options) returns true if a
.I path
exists, regardless of mode or type.
These options determine the test to apply to the
.IR path s:
.RS
.TS
tab(@);
lb l .
-r@Is the path readable?
-w@Is the path writable?
-x@Is the path executable?
-f@Is the path a plain file?
-d@Is the path a directory?
-c@Is the path a character device?
-b@Is the path a block device?
-l@Is the path a symbolic link?
-s@Is the path a socket?
-p@Is the path a named pipe?
.TE
.PP
With the
.BI -n " name"
option, the
.IR path s
are applied to
.IR name ,
producing a list of test results.
.PP
With
.BR -1 ", " access
returns the first
.I path
to satisfy the test.
If no
.I path
satisfies the test, return the empty list unless
.BR -e
was specified, in which case not having a satisfied test causes an
error to be raised.
.RE
.TP
.BI alias " name expansion..."
Define a function with
.I expansion
as its body.
The first word of
.I expansion
is replaced with its
.B whats
value to prevent the recursion that would occur if
.I name
and the first word of
.I expansion
are the same.
.TP
.BI catch " catcher body"
Run
.IR body .
If an exception is raised, run
.IR catcher .
The exception is passed as an argument to
.IR catcher .
.TP
.BR cd " [" \fIdirectory ]
Set the working directory to
.IR directory .
With no argument, this is the same as
.BR "cd $home" .
.TP
.BR dirs " [" -c ]
Show the directory stack (see
.BR pushd " and " popd ).
With
.BR -c ,
clear the directory stack.
.TP
.BR echo " [" -n "] [" -- ] " \fIargs..."
Print
.I args
to standard output, separated by spaces.
The output ends with a newline unless suppressed by
.BR -n .
Arguments following
.B --
are taken literally.
.TP
.BI escape " lambda"
Run
.IR lambda ,
a function of one argument.
The argument names a function (like
.BI fn- somename \fR)
which, when evaluated within
.IR lambda ,
transfers control to just after the
.B escape
form.
Arguments of the escape function are returned as the value of the form.
.TP
.BI eval " list"
Convert
.I list
to a word and pass it to the
.B xs
interpreter for parsing and execution.
.RS
.PP
Lexical bindings are not available to
.BR eval .
The following code prints "dyn":
.PP
.RS
.EX
 x = dyn
 let (x = lex) {
     eval 'echo $x'
 }
.EE
.RE
.RE
.TP
.BI exec " cmd"
Replace
.B xs
with
.IR cmd .
If
.I cmd
has only redirections, then apply the redirections to the current
.BR xs .
.TP
.BR exit " [" \fIstatus ]
Cause
.B xs
to exit with the given
.IR status ,
or with zero if
.I status
is not given.
.TP
.B false
Identical to
.BR "result 1" .
.TP
.BI fn " name fragment"
See
.BR Functions .
.TP
.BI for " vars-and-values... fragment"
See
.BR Loops .
.TP
.BI forever " fragment"
See
.BR Loops .
.TP
.BI fork " command"
Run
.I command
in a subshell.
Signals are not processed during execution of
.IR command .
.TP
.BR history " [" \fI# | -c | "-d \fI#" | -n | -y ]
Without arguments, show command history.
.I #
shows the most recent
.I #
history entries.
.B -c
clears the history.
.BI -d " #"
deletes history entry
.IR # .
.B -n
and
.B -y
disable and enable history recording.
.TP
.BI if " condition fragment \fR[" else " fragment\fR]"
See
.BR Conditionals .
.TP
.B jobs
List background jobs.
.TP
.BI let " bindings fragment"
See
.BR "Lexical Variables" .
.TP
.BR limit " [" -h "] [" \fIresource " [" \fIvalue ]]
Display or alter process resource limits.
.B -h
for hard limits.
.I Value
is either
.B unlimited
or a number.
Numbers representing size allow the suffixes
.B k
(kilobyte),
.B m
(megabyte), and
.B g
(gigabyte).
Numbers representing time allow the suffixes
.B s
(seconds),
.B m
(minutes), and
.B h
(hours) as well as durations like
.IR hh : mm : "ss and mm" : ss.
.TP
.BI local " bindings fragment"
See
.BR "Local Variables" .
.TP
.BI map " action list"
Apply
.I action
individually to each element of
.IR list ;
collect the results as
.BR map 's
result.
.TP
.BI omap " action list"
Like map, but collect a list of the outputs of
.IR action .
.TP
.B popd
Pop the directory stack to set the working directory, and print the new
stack.
The command is ignored if the directory stack is empty.
.TP
.BI printf " format args..."
Print
.I args
on standard output according to
.IR format .
Valid
.I format
conversions are those of
.BR printf (3p),
except that there must be a one-to-correspondence between format specs
(excluding
.BR %% )
and arguments: positional argument specs, variable width and precision,
and excess arguments are all disallowed.
Escapes must be unquoted in
.IR format .
.TP
.BR pushd " [" \fIdir ]
Push
.IR dir 's
absolute path onto the directory stack, set the working directory to
.I dir
and show the new stack.
If
.I dir
is omitted and the stack is at least two deep, then alternate between
the two top directories.
.TP
.B read
Read from standard input and return a single word containing a line of
text (without the newline).
Return
.B ()
upon end-of-file.
.TP
.BI result " value..."
Return
.IR value s.
.TP
.BI signals-case " fragment handlers_alist"
See
.BR Signals .
.TP
.BI sleep " seconds"
Sleep for
.IR seconds .
Fractional times are allowed.
Negative times are treated as zero.
.TP
.BR switch " \fIvalue [" "\fIcase \fIaction" "]... [" \fIdefault-action ]
See
.BR Conditionals .
.TP
.BI throw " exception arg..."
See
.BR Exceptions .
.TP
.BI time " command arg..."
Execute
.I command
with
.IR arg s.
Print consumed real, user and system time to standard error.
.TP
.B true
Identical to
.BR "result 0" .
.TP
.BR umask " [\fImask\fR]
Set or show the umask.
.TP
.BI until " test body"
See
.BR Loops .
.TP
.BI unwind-protect " body cleanup"
Execute
.IR body ;
when it completes or raises an exception, run
.IR cleanup .
.TP
.BI var " var..."
Print definition of
.IR var (s).
.TP
.BR vars " [" -vfs "] [" -epi ]
Print definition of all variables which satisfy the given options:
.TS
tab(@);
l lx .
-v@T{
variables (not functions or settors).
This is the default if none of
.BR -v ", " -f " or " -s
is given.
T}
-f@functions
-s@settors
-e@T{
exported.
This is the default if none of
.BR -e ", " -p " or " -i
is given.
T}
-p@private (not exported)
-i@internal (predefined and builtin)
-a@all of the above
.TE
.TP
.BR wait " [\fIpid\fR]
Wait for a child process denoted by its
.I pid
to exit.
If no
.I pid
is given, wait for any child process.
.TP
.BI whats " command..."
Identify
.IR command (s)
by pathname, primitive, or fragment.
.TP
.BI while " test body"
See
.BR Loops .
.RE
.SH HOOK FUNCTIONS
The following functions implement specific parts of
.B xs
semantics; a hook function can be rewritten to provide special behaviors.
Hook functions are normally called as a result of
.B xs
translating programs into an internal form.
See
.BR "CANONICAL FORM" .
.TP
.BI %and " command..."
Execute
.IR command (s)
from left to right, stopping at the command that first yields a false
value.
The false value is returned by
.BR %and .
.TP
.BI %append " fd file command"
Run
.I command
with
.I fd
open in append mode on
.IR file .
.TP
.BI %background " command"
Run
.I command
as a background process.
If
.B xs
is an interactive shell, print the background process ID.
.TP
.BI %backquote " separators command"
Run command as a child process, splitting standard output into words at
any character in
.IR separators .
.TP
.BI %close " fd command"
Run
.I command
with the closed file descriptor
.IR fd .
.TP
.BI %cmp " word1 word2"
Compare
.IR word1 " to " word2
and return -1, 0 or 1 if
.I word1
is respectively less than, equal to or greater than
.IR word2 .
If either argument is non-numeric, then a lexicographic comparison is
done based upon the locale's collation order.
.TP
.BI %count " list"
Return the number of words in
.IR list .
.TP
.BI %create " fd file command"
Run
.I command
with
.I fd
open for writing on
.IR file .
.TP
.BI %dup " newfd oldfd command"
Run
.I command
with
.I oldfd
copied to
.IR newfd .
.TP
.BI %exit-on-false " command"
Run
.IR command ;
exit
.B xs
if any part of
.I command
(outside of conditional tests and arguments to logical operators)
returns a false value.
.TP
.BI %flatten " separator list"
Concatenate the words of
.IR list ,
interposing
.IR separator .
.TP
.BI %here " fd word... command"
Run command with
.IR word s
passed as an input file on
.IR fd .
.TP
.BI %not " command"
Run command and invert the boolean sense of its result.
.TP
.BI %one " list"
Return
.I list
if it contains exactly one word; otherwise raise a "too many files in
redirection" error.
.TP
.BI %open " fd file command"
Run
.I command
with
.I file
open for reading on
.IR fd .
.TP
.BI %open-append " fd file command"
Run
.I command
with
.I file
open for reading and appending on
.IR fd .
.TP
.BI %open-create " fd file command"
Run
.I command
with
.I file
open for reading and writing on
.IR fd .
If the file exists, truncate it.
.TP
.BI %open-write " fd file command"
Run
.I command
with
.I file
open for reading and writing on
.IR fd .
.TP
.BI %openfile " mode fd file command"
Run
.I command
with
.I file
open on
.I fd
with the given
.IR mode .
.TP
.BI %or " command..."
Execute
.IR command (s)
from left to right, stopping at the command that first yields a true
value.
The true value is returned by
.BR %or .
.TP
.BI %pathsearch " program"
If
.I program
exists in a directory on
.BR $path ,
return the full path to
.IR program .
Otherwise raise an error.
.TP
.BR %pipe " \fIcommand1\fR [\fIoutfd infd command2\fR] ..."
Run
.IR command s
with
.I outfd
of
.I command1
connected via a pipe to
.I infd
of
.IR command2 .
Additional commands may be added to the pipeline.
.TP
.BI %readfrom " var input command"
Run command with
.I var
bound to the name of a file containing the standard output produced by the
command
.IR input .
.TP
.BI %seq " command..."
Run
.IR command s
in order, from left to right.
.TP
.BI %whats " program..."
Return the pathname, primitive, or fragment of each
.IR program .
.TP
.BI %writeto " var output command"
Run command with
.I var
bound to the name of a file containing the standard input to be consumed
by the command
.IR output .
.SH UTILITY FUNCTIONS
These functions also define
.B xs
behavior, but are less useful for customization:
.TP
.B %apids
Return the process IDs of all background processes for which
.B xs
has not yet waited.
.TP
.BI %fsplit " separators arg..."
Split each
.I arg
word at any
.I separators
character, producing a list.
Repeated instances of
.I separators
in
.IR arg s
create empty words
.RB ( \(aq\(aq )
in the result.
.TP
.B %is-interactive
Return true if the innermost toploop is interactive.
.TP
.B %is-login
Return true if this is a login shell.
.TP
.B %newfd
Return a file descriptor that the shell believes is not otherwise used.
.TP
.BI %run " program argv0 args..."
Run
.IR program ,
which must be an absolute pathname, passing
.I argv0
as the program's name and
.IR arg s
as its arguments.
.TP
.BI %split " separators arg..."
Like
.BR %fsplit ,
but repeated instances of a
.I separators
character in
.IR arg s
are coalesced.
.TP
.BI %var " var..."
Return the definition of each
.IR var .
.SH PRIMITIVE FUNCTIONS
Primitives provide the underlying behaviors for many hooks and builtins,
and may not be redefined.
.TS
tab(@);
lb | lb
lb | l .
Primitive@Implements
_
$&access@access
$&apids@%apids
$&background@\fIused by \fR%background
$&backquote@\fIused by \fR%backquote
$&batchloop@%batch-loop
$&catch@\fIused by \fRcatch \fIand \fRsignals-case
$&cd@\fIused by \fRcd
$&close@%close
$&cmp@%cmp
$&collect@\fIinvokes GC
$&count@%count
$&dot@.
$&dup@%dup
$&echo@echo
$&exec@exec
$&exitonfalse@%exit-on-false
$&flatten@%flatten
$&forever@forever
$&fork@fork
$&fsplit@%fsplit
$&here@%here
$&home@%home
$&if@if
$&internals@\fIused by \fRvars
$&isinteractive@%is-interactive
$&islogin@%is-login
$&len@\fIcount chars in word(s)
$&limit@limit
$&newfd@%newfd
$&newpgrp@newpgrp
$&openfile@%openfile
$&parse@%parse
$&pipe@%pipe
$&primitives@\fIlist xs primitives
$&printf@printf
$&random@\fIrandom integer
$&read@%read
$&readfrom@%readfrom
$&getc@\fIread one character
$&tctl@\fIset terminal control (cooked, raw, echo, noecho)
$&resetterminal@\fIused to keep readline(3) in sync with terminal
$&result@result
$&run@%run
$&seq@%seq
$&sethistory@\fIsettor implementing \fRset-history
$&setmaxevaldepth@\fIsettor implementing \fRset-max-eval-depth
$&setnoexport@\fIsettor implementing \fRset-noexport
$&setsignals@\fIsettor implementing \fRset-signals
$&sleep@sleep
$&split@%split
$&throw@throw
$&time@time
$&umask@umask
$&var@%var
$&vars@\fIused by \fRvars
$&version@\fIversion info
$&wait@wait
$&whats@%whats
$&wid@\fIcount character cells in word(s)
$&writeto@%writeto
.TE
.SH TOPLOOPS
A toploop repeatedly reads and executes a command and prints its result.
.B Xs
has two toploops, one of which is selected depending upon
.B xs
options.
.PP
.TP
.B %batch-loop
This is the toploop for a non-interactive shell and for the dot
.RB ( . )
and
.B eval
commands when their input is non-interactive.
.B %batch-loop
returns upon catching an exception.
.TP
.B %interactive-loop
This is the toploop for an interactive shell and for the dot
.RB ( . )
and
.B eval
commands when their input is interactive.
.B %interactive-loop
returns upon catching an
.B eof
exception.
.RS
.PP
The
.B %interactive-loop
has a hook function,
.BR %before-interactive-prompt ;
if defined, this is called \(em passing the return code of the prior
command \(em after
.B %prompt
but before printing the initial prompt.
.RE
.PP
.B Xs
binds one of the following functions to
.B fn-%dispatch
for use by the toploop.
The choice of function is determined by whether the shell is interactive
and by the
.BR -n " and " -x
options.
.PP
.RS
.BI %eval-noprint " command"
.RE
.RS
.BI %eval-print " command"
.RE
.RS
.BI %noeval-noprint " command"
.RE
.RS
.BI %noeval-print " command"
.RE
.PP
These functions handle command input for the shell:
.TP
.BI %parse " prompt1 prompt2"
Read input after printing
.I prompt1
initially and
.I prompt2
for continuation lines.
Return a fragment suitable for execution.
Raise an
.B eof
exception at end of input.
.P
.B %prompt
.B Xs
calls this hook immediately before
.BR %parse .
A common use is to update the value of
.BR $prompt .
.SH CANONICAL FORM
.B Xs
rewrites surface syntax in terms of hook functions.
.SS Control flow
.TS
tab(@);
l lx .
\fB! \fIcommand@T{
%not {\fIcommand\fR}
T}
\fIcommand \fB&@T{
%background {\fIcommand\fR}
T}
\fIcommand1 \fB; \fIcommand2@T{
%seq {\fIcommand1\fR} {\fIcommand2\fR}
T}
\fIcommand1 \fB&& \fIcommand2@T{
%and {\fIcommand1\fR} {\fIcommand2\fR}
T}
\fIcommand1 \fB|| \fIcommand2@T{
%or {\fIcommand1\fR} {\fIcommand2\fR}
T}
\fBfn \fIname\fB {|\fIarg...\fB| \fIcommand\fB}@T{
fn-^\fIname\fR = {|\fIarg...\fR|\fI command\fR}
T}
.TE
.SS Input/output
.TS
tab(@);
l lx .
\fIcommand \fB< \fIfile@T{
%open 0 \fIfile\fR {\fIcommand\fR}
T}
\fIcommand \fB> \fIfile@T{
%create 1 \fIfile\fR {\fIcommand\fR}
T}
\fIcommand \fB>[\fIn\fB] \fIfile@T{
%create \fIn\fR \fIfile\fR {\fIcommand\fR}
T}
\fIcommand \fB>> \fIfile@T{
%append 1 \fIfile\fR {\fIcommand\fR}
T}
\fIcommand \fB<> \fIfile@T{
%open-write 0 \fIfile\fR {\fIcommand\fR}
T}
\fIcommand \fB<>> \fIfile@T{
%open-append 0 \fIfile\fR {\fIcommand\fR}
T}
\fIcommand \fB>< \fIfile@T{
%open-create 1 \fIfile\fR {\fIcommand\fR}
T}
\fIcommand \fB>>< \fIfile@T{
%open-append 1 \fIfile\fR {\fIcommand\fR}
T}
\fIcommand \fB>[\fIn\fB=]@T{
%close \fIn\fR {\fIcommand\fR}
T}
\fIcommand \fB>[\fIm\fB=\fIn\fB]@T{
%dup \fIm\fR \fIn\fR {\fIcommand\fR}
T}
\fIcommand \fB<< \fItag input tag@T{
%here 0 \fIinput\fR {\fIcommand\fR}
T}
\fIcommand \fB<<< \fIword@T{
%here 0 \fIword\fR {\fIcommand\fR}
T}
\fIcommand1 \fB| \fIcommand2@T{
%pipe {\fIcommand1\fR} 1 0 {\fIcommand2\fR}
T}
\fIcommand1 \fB|[\fIm\fB=\fIn\fB] \fIcommand2@T{
%pipe {\fIcommand1\fR} \fIm\fR \fIn\fR {\fIcommand2\fR}
T}
\fIcommand1 \fB>{ \fIcommand2 \fB}@T{
%writeto \fIvar\fR {\fIcommand2\fR} {\fIcommand1\fR $\fIvar\fR}
T}
\fIcommand1 \fB<{ \fIcommand2 \fB}@T{
%readfrom \fIvar\fR {\fIcommand2\fR} {\fIcommand1\fR $\fIvar\fR}
T}
.TE
.SS Expressions
.TS
tab(@);
l lx .
\fB$#\fIvar@T{
<={%count %\fIvar\fR}
T}
\fB$^\fIvar@T{
<={%flatten \(aq \(aq $\fIvar\fR}
T}
\fB\`{ \fIcommand arg... \fB}@T{
<={%backquote <={%flatten \(aq\(aq $ifs} {\fIcommand\fR \fIarg...\fR}}
T}
\fB\`\` \fIifs \fB{ \fIcommand arg... \fB}@T{
<={%backquote <={%flatten \(aq\(aq \fIifs\fR} {\:\fIcommand\fR \fIarg...\fR}}
T}
.TE
.SS Relational operators
.TS
tab(@);
l lx .
\fIa \fB:lt \fIb@T{
{~ {%cmp \fIa\fR \fIb\fR} -1}
T}
\fIa \fB:le \fIb@T{
{~ {%cmp \fIa\fR \fIb\fR} -1 0}
T}
\fIa \fB:gt \fIb@T{
{~ {%cmp \fIa\fR \fIb\fR} 1}
T}
\fIa \fB:ge \fIb@T{
{~ {%cmp \fIa\fR \fIb\fR} 1 0}
T}
\fIa \fB:eq \fIb@T{
{~ {%cmp \fIa\fR \fIb\fR} 0}
T}
\fIa \fB:ne \fIb@T{
{~ {%cmp \fIa\fR \fIb\fR} -1 1}
T}
.TE
.SH ENVIRONMENT
.B Xs
reads the following environment variables.
.TS
tab(@);
lb lb lb
l l l .
Variable@Default@Usage
HOME@/@define ~
PATH@/usr/bin:/bin:@locate executables
.TE
.PP
.B Xs
sets the following environment variables.
.TS
tab(@);
lb lb
l l .
Variable@Usage
SHLVL@track shell nesting level
.TE
.SH EDITING
Input editing is provided by
.BR readline (3)
and configured by
.BR ~/.inputrc .
The
.BR ~/.inputrc
file may contain definitions specifically for
.BR xs ,
and not other
.BR readline "(3)-aware programs,"
through use of the conditional construct
.IR "$if xs" .
.SH FILES
These files are read and interpreted when
.B xs
starts:
.RS
.TP
.B ~/.xsrc
when
.B xs
is a login shell
.TP
.B ~/.xsin
when
.B xs
is an interactive shell
.RE
.PP
When both
.BR ~/.xsrc " and " ~/.xsin
are read,
.B ~/.xsrc
is read first.
.SH SEE ALSO
Additional documentation is installed in
.IB prefix /share/doc/xs
.RI .
.I Prefix
is typically
.BR /usr " or " /usr/local .
.SH DEPRECATIONS
The following forms are deprecated and should not be used for new
.B xs
code.
.RS
.TS
tab(@);
r lx .
\fB\eu\fInnnn@T{
UTF-8 character having codepoint
.IR nnnn ,
for
.I n
in {0..9, a..f, A..F}
T}
\fB\eU\fInnnnnnnn@T{
UTF-8 character having codepoint
.IR nnnnnnnn ,
for
.I n
in {0..9, a..f, A..F}
T}
.TE
.RE
.PP
.B NOTICE:
Deprecated features, syntax and behaviors are preserved only until the
next major release of
.BR xs .
.SH BUGS
The shell does not support job control.
.PP
The interpreter does not implement tail recursion.
.PP
.B Xs
reserves the octets \e001 and \e002 to annotate variables stored in
the environment.
This may present problems for interchange of variables
with another program that stores these octets in the environment.
.PP
Please report issues at <https://github.com/TieDyedDevil/XS>.
.SH SOURCE
The
.BR git (1)
source repository is at <https://github.com/TieDyedDevil/XS>.
.SH PACKAGES
.B Xs
is packaged for Fedora.
The
.B xs
1.1 release first appeared in Fedora 27.
.SH AUTHORS
.B Xs
1.1 and later is maintained by David B.\& Lamkins <david@lamkins.net>.
.PP
.B Xs
1.0 (self-reporting as 0.1) was maintained by Frederic Koehler
<fkfire@gmail.com>.
.PP
.B Es
to 0.9-beta was maintained by Soren Dayton <csdayton@cs.uchicago.edu>.
.B Es
up through 0.84 was maintained by Paul Haar <haahr@adobe.com> and
Byron Rakitzis <byron@netapp.com>.
.PP
The
.B rc
shell for Plan 9 was written at Bell Labs by Tom Duff.
The Unix port was
written by Byron Rakitizis and maintained by Toby Goodwin.
See <http://tobold.org/article/rc>.
.PP
Other contributors may be found in the CHANGES file and in the commit log.
.SH FOOTNOTE
Yes, and of course whitespace.
Some things should be left unsaid.
